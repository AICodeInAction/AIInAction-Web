import type { AchievementRarity } from "@prisma/client";
import { prisma } from "./prisma";

export type AchievementTrigger =
  | "challenge_complete"
  | "challenge_publish"
  | "like_received"
  | "fork_received";

export type AchievementDefinition = {
  slug: string;
  name: string;
  description: string;
  icon: string;
  xpReward: number;
  rarity: AchievementRarity;
};

export const ACHIEVEMENT_DEFINITIONS: AchievementDefinition[] = [
  // Completion achievements
  {
    slug: "first-step",
    name: "ç¬¬ä¸€æ­¥",
    description: "å®Œæˆç¬¬ä¸€ä¸ªæŒ‘æˆ˜",
    icon: "ğŸ¯",
    xpReward: 10,
    rarity: "COMMON",
  },
  {
    slug: "ten-complete",
    name: "åå…¨åç¾",
    description: "å®Œæˆ 10 ä¸ªæŒ‘æˆ˜",
    icon: "ğŸ”Ÿ",
    xpReward: 50,
    rarity: "RARE",
  },
  {
    slug: "hundred-complete",
    name: "ç™¾ç‚¼æˆé’¢",
    description: "å®Œæˆ 100 ä¸ªæŒ‘æˆ˜",
    icon: "ğŸ’¯",
    xpReward: 200,
    rarity: "LEGENDARY",
  },
  {
    slug: "all-difficulties",
    name: "å…¨èƒ½ AI",
    description: "å®Œæˆå…¨éƒ¨ 4 ä¸ªéš¾åº¦å„ 1 ä¸ª",
    icon: "ğŸ§ ",
    xpReward: 100,
    rarity: "EPIC",
  },
  // Difficulty achievements
  {
    slug: "green-belt",
    name: "ç»¿å¸¦",
    description: "å®Œæˆ 5 ä¸ª BEGINNER æŒ‘æˆ˜",
    icon: "ğŸŸ¢",
    xpReward: 20,
    rarity: "COMMON",
  },
  {
    slug: "blue-belt",
    name: "è“å¸¦",
    description: "å®Œæˆ 5 ä¸ª INTERMEDIATE æŒ‘æˆ˜",
    icon: "ğŸ”µ",
    xpReward: 30,
    rarity: "RARE",
  },
  {
    slug: "red-belt",
    name: "çº¢å¸¦",
    description: "å®Œæˆ 5 ä¸ª ADVANCED æŒ‘æˆ˜",
    icon: "ğŸ”´",
    xpReward: 50,
    rarity: "EPIC",
  },
  {
    slug: "black-belt",
    name: "é»‘å¸¦",
    description: "å®Œæˆ 1 ä¸ª EXPERT æŒ‘æˆ˜",
    icon: "âš«",
    xpReward: 50,
    rarity: "EPIC",
  },
  // Streak achievements
  {
    slug: "streak-3",
    name: "ä¸‰æ—¥ä¸æ¯",
    description: "è¿ç»­ 3 å¤©å®ŒæˆæŒ‘æˆ˜",
    icon: "ğŸ”¥",
    xpReward: 15,
    rarity: "COMMON",
  },
  {
    slug: "streak-7",
    name: "å‘¨æ›´è¾¾äºº",
    description: "è¿ç»­ 7 å¤©å®ŒæˆæŒ‘æˆ˜",
    icon: "ğŸ”¥ğŸ”¥",
    xpReward: 50,
    rarity: "RARE",
  },
  {
    slug: "streak-30",
    name: "æœˆä¸åœæ­‡",
    description: "è¿ç»­ 30 å¤©å®ŒæˆæŒ‘æˆ˜",
    icon: "ğŸ”¥ğŸ”¥ğŸ”¥",
    xpReward: 200,
    rarity: "LEGENDARY",
  },
  // Social achievements
  {
    slug: "creator",
    name: "åˆ›ä½œè€…",
    description: "å‘å¸ƒç¬¬ 1 ä¸ªæŒ‘æˆ˜",
    icon: "âœï¸",
    xpReward: 20,
    rarity: "COMMON",
  },
  {
    slug: "popular",
    name: "å—æ¬¢è¿",
    description: "å‘å¸ƒçš„æŒ‘æˆ˜è·å¾— 10 ä¸ªèµ",
    icon: "ğŸŒŸ",
    xpReward: 50,
    rarity: "RARE",
  },
  {
    slug: "influencer",
    name: "å½±å“åŠ›",
    description: "å‘å¸ƒçš„æŒ‘æˆ˜è¢« Fork 5 æ¬¡",
    icon: "ğŸ¤",
    xpReward: 50,
    rarity: "RARE",
  },
  // Path achievements
  {
    slug: "path-pioneer",
    name: "è·¯å¾„å…ˆé©±",
    description: "å®Œæˆç¬¬ä¸€æ¡å­¦ä¹ è·¯å¾„",
    icon: "ğŸ—ºï¸",
    xpReward: 100,
    rarity: "EPIC",
  },
  {
    slug: "path-master",
    name: "å…¨è·¯å¾„å¤§å¸ˆ",
    description: "å®Œæˆæ‰€æœ‰å­¦ä¹ è·¯å¾„",
    icon: "ğŸ†",
    xpReward: 500,
    rarity: "LEGENDARY",
  },
];

type UnlockedAchievement = {
  slug: string;
  name: string;
  description: string;
  icon: string;
  xpReward: number;
  rarity: AchievementRarity;
};

export async function checkAndAwardAchievements(
  userId: string,
  trigger: AchievementTrigger
): Promise<UnlockedAchievement[]> {
  const newlyUnlocked: UnlockedAchievement[] = [];

  // Get existing achievements for this user
  const existing = await prisma.userAchievement.findMany({
    where: { userId },
    select: { achievement: { select: { slug: true } } },
  });
  const unlockedSlugs = new Set(existing.map((e) => e.achievement.slug));

  // Determine which achievements to check based on trigger
  const checksToRun = getChecksForTrigger(trigger);

  for (const check of checksToRun) {
    if (unlockedSlugs.has(check.slug)) continue;

    const earned = await check.condition(userId);
    if (!earned) continue;

    // Find the achievement in DB
    const achievement = await prisma.achievement.findUnique({
      where: { slug: check.slug },
    });
    if (!achievement) continue;

    // Idempotent: use upsert to prevent duplicates
    await prisma.userAchievement.upsert({
      where: {
        userId_achievementId: { userId, achievementId: achievement.id },
      },
      update: {},
      create: { userId, achievementId: achievement.id },
    });

    newlyUnlocked.push({
      slug: achievement.slug,
      name: achievement.name,
      description: achievement.description,
      icon: achievement.icon,
      xpReward: achievement.xpReward,
      rarity: achievement.rarity,
    });
  }

  return newlyUnlocked;
}

type AchievementCheck = {
  slug: string;
  condition: (userId: string) => Promise<boolean>;
};

function getChecksForTrigger(trigger: AchievementTrigger): AchievementCheck[] {
  switch (trigger) {
    case "challenge_complete":
      return [
        ...completionChecks,
        ...difficultyChecks,
        ...streakChecks,
        ...pathChecks,
      ];
    case "challenge_publish":
      return [creatorCheck];
    case "like_received":
      return [popularCheck];
    case "fork_received":
      return [influencerCheck];
  }
}

// --- Completion checks ---
const completionChecks: AchievementCheck[] = [
  {
    slug: "first-step",
    condition: async (userId) => {
      const count = await prisma.challengeCompletion.count({
        where: { userId, status: "COMPLETED" },
      });
      return count >= 1;
    },
  },
  {
    slug: "ten-complete",
    condition: async (userId) => {
      const count = await prisma.challengeCompletion.count({
        where: { userId, status: "COMPLETED" },
      });
      return count >= 10;
    },
  },
  {
    slug: "hundred-complete",
    condition: async (userId) => {
      const count = await prisma.challengeCompletion.count({
        where: { userId, status: "COMPLETED" },
      });
      return count >= 100;
    },
  },
  {
    slug: "all-difficulties",
    condition: async (userId) => {
      const completions = await prisma.challengeCompletion.findMany({
        where: { userId, status: "COMPLETED" },
        select: { challenge: { select: { difficulty: true } } },
      });
      const difficulties = new Set(
        completions.map((c) => c.challenge.difficulty)
      );
      return (
        difficulties.has("BEGINNER") &&
        difficulties.has("INTERMEDIATE") &&
        difficulties.has("ADVANCED") &&
        difficulties.has("EXPERT")
      );
    },
  },
];

// --- Difficulty checks ---
const difficultyChecks: AchievementCheck[] = [
  {
    slug: "green-belt",
    condition: async (userId) => {
      const count = await prisma.challengeCompletion.count({
        where: {
          userId,
          status: "COMPLETED",
          challenge: { difficulty: "BEGINNER" },
        },
      });
      return count >= 5;
    },
  },
  {
    slug: "blue-belt",
    condition: async (userId) => {
      const count = await prisma.challengeCompletion.count({
        where: {
          userId,
          status: "COMPLETED",
          challenge: { difficulty: "INTERMEDIATE" },
        },
      });
      return count >= 5;
    },
  },
  {
    slug: "red-belt",
    condition: async (userId) => {
      const count = await prisma.challengeCompletion.count({
        where: {
          userId,
          status: "COMPLETED",
          challenge: { difficulty: "ADVANCED" },
        },
      });
      return count >= 5;
    },
  },
  {
    slug: "black-belt",
    condition: async (userId) => {
      const count = await prisma.challengeCompletion.count({
        where: {
          userId,
          status: "COMPLETED",
          challenge: { difficulty: "EXPERT" },
        },
      });
      return count >= 1;
    },
  },
];

// --- Streak checks ---
const streakChecks: AchievementCheck[] = [
  {
    slug: "streak-3",
    condition: async (userId) => {
      const stats = await prisma.userStats.findUnique({ where: { userId } });
      return (stats?.longestStreak ?? 0) >= 3;
    },
  },
  {
    slug: "streak-7",
    condition: async (userId) => {
      const stats = await prisma.userStats.findUnique({ where: { userId } });
      return (stats?.longestStreak ?? 0) >= 7;
    },
  },
  {
    slug: "streak-30",
    condition: async (userId) => {
      const stats = await prisma.userStats.findUnique({ where: { userId } });
      return (stats?.longestStreak ?? 0) >= 30;
    },
  },
];

// --- Path checks ---
const pathChecks: AchievementCheck[] = [
  {
    slug: "path-pioneer",
    condition: async (userId) => {
      // Check if user completed all challenges in any learning path
      const paths = await prisma.learningPath.findMany({
        include: { challenges: { select: { id: true } } },
      });
      for (const path of paths) {
        if (path.challenges.length === 0) continue;
        const completedCount = await prisma.challengeCompletion.count({
          where: {
            userId,
            status: "COMPLETED",
            challengeId: { in: path.challenges.map((c) => c.id) },
          },
        });
        if (completedCount >= path.challenges.length) return true;
      }
      return false;
    },
  },
  {
    slug: "path-master",
    condition: async (userId) => {
      const paths = await prisma.learningPath.findMany({
        include: { challenges: { select: { id: true } } },
      });
      const pathsWithChallenges = paths.filter(
        (p) => p.challenges.length > 0
      );
      if (pathsWithChallenges.length === 0) return false;
      for (const path of pathsWithChallenges) {
        const completedCount = await prisma.challengeCompletion.count({
          where: {
            userId,
            status: "COMPLETED",
            challengeId: { in: path.challenges.map((c) => c.id) },
          },
        });
        if (completedCount < path.challenges.length) return false;
      }
      return true;
    },
  },
];

// --- Social checks ---
const creatorCheck: AchievementCheck = {
  slug: "creator",
  condition: async (userId) => {
    const count = await prisma.challenge.count({
      where: { authorId: userId, isOfficial: false },
    });
    return count >= 1;
  },
};

const popularCheck: AchievementCheck = {
  slug: "popular",
  condition: async (userId) => {
    const totalLikes = await prisma.challengeLike.count({
      where: { challenge: { authorId: userId } },
    });
    return totalLikes >= 10;
  },
};

const influencerCheck: AchievementCheck = {
  slug: "influencer",
  condition: async (userId) => {
    const totalForks = await prisma.challenge.count({
      where: { forkedFrom: { authorId: userId } },
    });
    return totalForks >= 5;
  },
};
